/**
 * Tests for Related Items Loader
 * 
 * Tests the YAML-based related-items CRUD operations for task feature folders.
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import {
    RELATED_ITEMS_FILENAME,
    loadRelatedItems,
    saveRelatedItems,
    hasRelatedItems,
    deleteRelatedItems,
    removeRelatedItem,
    mergeRelatedItems,
    getRelatedItemsPath,
    categorizeItem,
} from '../../src/tasks/related-items-loader';
import { RelatedItem, RelatedItemsConfig } from '../../src/tasks/types';
import { setLogger, nullLogger, Logger, resetLogger } from '../../src/logger';

describe('Related Items Loader', () => {
    let tempDir: string;

    beforeEach(() => {
        tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'related-items-test-'));
        // Suppress console output during tests
        setLogger(nullLogger);
    });

    afterEach(() => {
        if (fs.existsSync(tempDir)) {
            fs.rmSync(tempDir, { recursive: true, force: true });
        }
        resetLogger();
    });

    // ========================================================================
    // loadRelatedItems
    // ========================================================================

    describe('loadRelatedItems', () => {
        it('returns undefined for missing file', async () => {
            const result = await loadRelatedItems(tempDir);
            expect(result).toBeUndefined();
        });

        it('parses valid YAML', async () => {
            const yamlContent = `description: "Test feature"
items:
  - type: file
    path: src/index.ts
    category: source
    description: "Main entry"
lastUpdated: "2026-01-01T00:00:00.000Z"
`;
            fs.writeFileSync(path.join(tempDir, RELATED_ITEMS_FILENAME), yamlContent);

            const result = await loadRelatedItems(tempDir);
            expect(result).toBeDefined();
            expect(result!.description).toBe('Test feature');
            expect(result!.items).toHaveLength(1);
            expect(result!.items[0].type).toBe('file');
            expect(result!.items[0].path).toBe('src/index.ts');
        });

        it('returns undefined for invalid YAML (non-object)', async () => {
            fs.writeFileSync(path.join(tempDir, RELATED_ITEMS_FILENAME), 'just a string');

            const result = await loadRelatedItems(tempDir);
            expect(result).toBeUndefined();
        });

        it('initializes empty items array when items is missing', async () => {
            const yamlContent = `description: "No items yet"
lastUpdated: "2026-01-01T00:00:00.000Z"
`;
            fs.writeFileSync(path.join(tempDir, RELATED_ITEMS_FILENAME), yamlContent);

            const result = await loadRelatedItems(tempDir);
            expect(result).toBeDefined();
            expect(result!.items).toEqual([]);
        });

        it('logs error on read failure', async () => {
            const errorMessages: string[] = [];
            const spyLogger: Logger = {
                debug: () => {},
                info: () => {},
                warn: () => {},
                error: (_cat, msg) => { errorMessages.push(msg); },
            };
            setLogger(spyLogger);

            // Create a directory named related.yaml so reading it as file fails
            const filePath = path.join(tempDir, RELATED_ITEMS_FILENAME);
            fs.mkdirSync(filePath);

            const result = await loadRelatedItems(tempDir);
            expect(result).toBeUndefined();
            expect(errorMessages.length).toBeGreaterThan(0);
            expect(errorMessages[0]).toContain(tempDir);
        });
    });

    // ========================================================================
    // saveRelatedItems
    // ========================================================================

    describe('saveRelatedItems', () => {
        it('writes YAML with header comment', async () => {
            const config: RelatedItemsConfig = {
                description: 'Test',
                items: [
                    { type: 'file', path: 'src/main.ts', category: 'source', description: 'Main' }
                ]
            };

            await saveRelatedItems(tempDir, config);

            const content = fs.readFileSync(path.join(tempDir, RELATED_ITEMS_FILENAME), 'utf-8');
            expect(content).toMatch(/^# Auto-generated by AI Discovery/);
            expect(content).toContain('# Feature:');
        });

        it('sets lastUpdated timestamp', async () => {
            const config: RelatedItemsConfig = {
                description: 'Test',
                items: []
            };

            await saveRelatedItems(tempDir, config);
            expect(config.lastUpdated).toBeDefined();
            // Should be a valid ISO string
            expect(new Date(config.lastUpdated!).toISOString()).toBe(config.lastUpdated);
        });

        it('creates file in correct location', async () => {
            const config: RelatedItemsConfig = {
                description: 'Test',
                items: []
            };

            await saveRelatedItems(tempDir, config);
            expect(fs.existsSync(path.join(tempDir, RELATED_ITEMS_FILENAME))).toBe(true);
        });
    });

    // ========================================================================
    // hasRelatedItems
    // ========================================================================

    describe('hasRelatedItems', () => {
        it('returns true when file exists', async () => {
            const config: RelatedItemsConfig = { description: '', items: [] };
            await saveRelatedItems(tempDir, config);

            expect(hasRelatedItems(tempDir)).toBe(true);
        });

        it('returns false when file absent', () => {
            expect(hasRelatedItems(tempDir)).toBe(false);
        });
    });

    // ========================================================================
    // deleteRelatedItems
    // ========================================================================

    describe('deleteRelatedItems', () => {
        it('removes file', async () => {
            const config: RelatedItemsConfig = { description: '', items: [] };
            await saveRelatedItems(tempDir, config);
            expect(hasRelatedItems(tempDir)).toBe(true);

            await deleteRelatedItems(tempDir);
            expect(hasRelatedItems(tempDir)).toBe(false);
        });

        it('no-ops when file does not exist', async () => {
            // Should not throw
            await deleteRelatedItems(tempDir);
            expect(hasRelatedItems(tempDir)).toBe(false);
        });
    });

    // ========================================================================
    // removeRelatedItem
    // ========================================================================

    describe('removeRelatedItem', () => {
        it('removes file-type item by path', async () => {
            const config: RelatedItemsConfig = {
                description: '',
                items: [
                    { type: 'file', path: 'src/a.ts', category: 'source', description: 'A' },
                    { type: 'file', path: 'src/b.ts', category: 'source', description: 'B' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const result = await removeRelatedItem(tempDir, 'src/a.ts');
            expect(result).toBe(true);

            const updated = await loadRelatedItems(tempDir);
            expect(updated!.items).toHaveLength(1);
            expect(updated!.items[0].path).toBe('src/b.ts');
        });

        it('removes commit-type item by hash', async () => {
            const config: RelatedItemsConfig = {
                description: '',
                items: [
                    { type: 'commit', hash: 'abc123', category: 'source', description: 'Fix bug' },
                    { type: 'commit', hash: 'def456', category: 'source', description: 'Add feature' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const result = await removeRelatedItem(tempDir, 'abc123');
            expect(result).toBe(true);

            const updated = await loadRelatedItems(tempDir);
            expect(updated!.items).toHaveLength(1);
            expect(updated!.items[0].hash).toBe('def456');
        });

        it('returns false when item not found', async () => {
            const config: RelatedItemsConfig = {
                description: '',
                items: [
                    { type: 'file', path: 'src/a.ts', category: 'source', description: 'A' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const result = await removeRelatedItem(tempDir, 'src/nonexistent.ts');
            expect(result).toBe(false);
        });

        it('returns false when no config exists', async () => {
            const result = await removeRelatedItem(tempDir, 'src/a.ts');
            expect(result).toBe(false);
        });
    });

    // ========================================================================
    // mergeRelatedItems
    // ========================================================================

    describe('mergeRelatedItems', () => {
        it('creates new config when none exists', async () => {
            const items: RelatedItem[] = [
                { type: 'file', path: 'src/new.ts', category: 'source', description: 'New' }
            ];

            const result = await mergeRelatedItems(tempDir, items, 'New feature');
            expect(result.description).toBe('New feature');
            expect(result.items).toHaveLength(1);
            expect(hasRelatedItems(tempDir)).toBe(true);
        });

        it('deduplicates files by path', async () => {
            const config: RelatedItemsConfig = {
                description: 'Existing',
                items: [
                    { type: 'file', path: 'src/a.ts', category: 'source', description: 'A' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const newItems: RelatedItem[] = [
                { type: 'file', path: 'src/a.ts', category: 'source', description: 'A duplicate' },
                { type: 'file', path: 'src/b.ts', category: 'source', description: 'B' },
            ];

            const result = await mergeRelatedItems(tempDir, newItems);
            expect(result.items).toHaveLength(2);
            // Original item preserved, not overwritten
            expect(result.items[0].description).toBe('A');
        });

        it('deduplicates commits by hash', async () => {
            const config: RelatedItemsConfig = {
                description: 'Existing',
                items: [
                    { type: 'commit', hash: 'abc123', category: 'source', description: 'Fix' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const newItems: RelatedItem[] = [
                { type: 'commit', hash: 'abc123', category: 'source', description: 'Same commit' },
                { type: 'commit', hash: 'def456', category: 'source', description: 'New commit' },
            ];

            const result = await mergeRelatedItems(tempDir, newItems);
            expect(result.items).toHaveLength(2);
        });

        it('updates description when provided', async () => {
            const config: RelatedItemsConfig = {
                description: 'Old description',
                items: []
            };
            await saveRelatedItems(tempDir, config);

            await mergeRelatedItems(tempDir, [], 'New description');

            const updated = await loadRelatedItems(tempDir);
            expect(updated!.description).toBe('New description');
        });

        it('preserves existing items', async () => {
            const config: RelatedItemsConfig = {
                description: 'Feature',
                items: [
                    { type: 'file', path: 'src/existing.ts', category: 'source', description: 'Existing' },
                ]
            };
            await saveRelatedItems(tempDir, config);

            const newItems: RelatedItem[] = [
                { type: 'file', path: 'src/new.ts', category: 'test', description: 'New' },
            ];

            const result = await mergeRelatedItems(tempDir, newItems);
            expect(result.items).toHaveLength(2);
            expect(result.items[0].path).toBe('src/existing.ts');
            expect(result.items[1].path).toBe('src/new.ts');
        });
    });

    // ========================================================================
    // getRelatedItemsPath
    // ========================================================================

    describe('getRelatedItemsPath', () => {
        it('returns correct joined path', () => {
            const result = getRelatedItemsPath('/some/folder');
            expect(result).toBe(path.join('/some/folder', RELATED_ITEMS_FILENAME));
        });
    });

    // ========================================================================
    // categorizeItem
    // ========================================================================

    describe('categorizeItem', () => {
        it('classifies test files by .test. pattern', () => {
            expect(categorizeItem('src/utils.test.ts')).toBe('test');
        });

        it('classifies test files by .spec. pattern', () => {
            expect(categorizeItem('src/utils.spec.ts')).toBe('test');
        });

        it('classifies test files by _test. pattern', () => {
            expect(categorizeItem('src/utils_test.go')).toBe('test');
        });

        it('classifies test files by /test/ directory', () => {
            expect(categorizeItem('src/test/helper.ts')).toBe('test');
        });

        it('classifies test files by /__tests__/ directory', () => {
            expect(categorizeItem('src/__tests__/helper.ts')).toBe('test');
        });

        it('classifies docs by .md extension', () => {
            expect(categorizeItem('docs/README.md')).toBe('doc');
        });

        it('classifies docs by .txt extension', () => {
            expect(categorizeItem('notes/todo.txt')).toBe('doc');
        });

        it('classifies docs by /docs/ directory', () => {
            expect(categorizeItem('project/docs/guide.html')).toBe('doc');
        });

        it('classifies config files - package.json', () => {
            expect(categorizeItem('package.json')).toBe('config');
        });

        it('classifies config files - .eslintrc', () => {
            expect(categorizeItem('.eslintrc')).toBe('config');
        });

        it('classifies config files - .yaml', () => {
            expect(categorizeItem('config/settings.yaml')).toBe('config');
        });

        it('defaults to source', () => {
            expect(categorizeItem('src/app.ts')).toBe('source');
            expect(categorizeItem('lib/utils.js')).toBe('source');
        });
    });

    // ========================================================================
    // generateYamlContent (tested indirectly via saveRelatedItems)
    // ========================================================================

    describe('generateYamlContent (indirect)', () => {
        it('output starts with Auto-generated header', async () => {
            const config: RelatedItemsConfig = {
                description: 'Test',
                items: []
            };
            await saveRelatedItems(tempDir, config);

            const content = fs.readFileSync(path.join(tempDir, RELATED_ITEMS_FILENAME), 'utf-8');
            expect(content.startsWith('# Auto-generated by AI Discovery')).toBe(true);
        });
    });
});
